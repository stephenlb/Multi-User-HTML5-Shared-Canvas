<html>

    <!-- âœ… TODO add number ONLINE USERS -->
<!-- TODO add canvas load history -->
<!-- TODO undo button -->
<!-- TODO line width PEN SIZE PEN SIZE -->
<!-- TODO canvas strech fix -->
    <head>
    <title>Shared Canvas</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<style>
body, html, div {
    margin: 0;
    padding: 0;
    overflow: hidden;
}
canvas {
    width: 100vw;
    height: 100vh;
    touch-action: none;
}

/* color canvas */
div#colors {
    display: flex;
    position: absolute;
    top: 20px;
    right: 20px;
    min-width: 200px;
    gap: 4px;
    box-shadow: 1px 1px 20px rgba(0,0,0,0.3);
    border: 2px solid rgba(255,255,255,0.1);
    background: rgba(255,255,255,0.1);
    padding: 8px;
    border-radius: 16px;
    backdrop-filter: blur(4px);
}

div#colors color {
    flex: 1;
    min-width: 30px;
    min-height: 30px;
    background-color: attr(hex type(<color>), red);
    border-radius: 8px;
    border: 2px solid rgba(255,255,255,0.2);
    transition: all 150ms cubic-bezier(.2,0,0,1);
}

div#colors color:active {
    scale: 1.4;
}
div#colors color.active {
    border: 2px solid white;
    box-shadow: 0 0 10px white;
    transform: scale(1.1);
}
div#occupancy {
    position: absolute; 
    bottom: 20px;
    left: 20px;
    font-size: 60px;
    font-weight: 800;
    color: #fff;
    text-shadow: 2px 2px #2e2e2e;
}
</style>

<canvas id=canvas width=500 height=500></canvas>

<div id=colors>
    <color hex=#ff0000 class=active></color>
    <color hex=#00ff00></color>
    <color hex=#0000ff></color>
    <color hex=#ffff00></color>
    <color hex=#00ffff></color>
    <color hex=#ff00ff></color>
    <color hex=#4a412a></color>
</div>

<div id=occupancy>1000</div>

<script src="pubnub.js"></script>
<script>
const userId  = `userId-${Math.random()}.${Math.random()}`;
const pubnub  = PubNub({userId: userId});
const channel = 'shared-canvas-v2';
const body    = document.querySelector('body');
const canvas  = document.getElementById('canvas');
const users   = {};
const context = canvas.getContext('2d');

// --- Detection Tracking ---
let myStrokes = [];
let currentStroke = [];

function getUser(id) {
    if (id in users) return users[id];
    users[id] = {
        userId     : id,
        drawing    : false,
        coords     : { x: 0, y: 0 },
        style      : 'red',
        lastCoords : null,
    };
    return users[id];
}

function clearCanvas() {
    context.fillStyle = "#181818";
    context.fillRect(0, 0, canvas.width, canvas.height);
}
clearCanvas();

function draw(userId) {
    const user   = getUser(userId);
    const coords = user.coords;
    const style  = user.style;

    if (!user.drawing) {
        user.lastCoords = null;
        return;
    }

    if (!user.lastCoords) {
        user.lastCoords = { x: coords.x, y: coords.y };
        return;
    }

    context.beginPath();
    context.strokeStyle = style;
    context.lineWidth = 5;
    context.lineCap = 'round';
    context.moveTo(user.lastCoords.x, user.lastCoords.y);
    context.lineTo(coords.x, coords.y);
    context.stroke();

    user.lastCoords = { x: coords.x, y: coords.y };
}

function capture(event) {
    event.preventDefault();
    const user = getUser(userId);
    user.coords = getXY(event);

    if (event.type === 'pointerdown') {
        user.drawing = true;
        currentStroke = [user.coords];
    }
    
    if (event.type === 'pointermove' && user.drawing) {
        currentStroke.push(user.coords);
    }

    if (event.type === 'pointerup') {
        user.drawing = false;
        if (currentStroke.length > 2) {
            myStrokes.push(currentStroke);
            checkShapeModeration();
        }
    }

    if (user.drawing || event.type === 'pointerup') broadcast(user);
}

canvas.addEventListener('pointerdown', capture);
canvas.addEventListener('pointermove', capture);
canvas.addEventListener('pointerup',   capture);

function getXY(event) {
    return {
        x: Math.floor((event.clientX / body.clientWidth) * canvas.width),
        y: Math.floor((event.clientY / body.clientHeight) * canvas.height),
    };
}

const colors = document.getElementById('colors');
colors.addEventListener( 'click', (event) => {
    const user = getUser(userId);
    const target = event.target;
    const color = target.getAttribute('hex');
    if (!color) return;
    user.style = color;
    document.querySelectorAll('#colors color').forEach(c => c.classList.remove('active'));
    target.classList.add('active');
});

pubnub.subscribe({
    channel: channel,
    messages: (state) => {
        if (state.action === 'clear') {
            clearCanvas();
            myStrokes = [];
            return;
        }
        const user = getUser(state.userId);
        Object.assign(user, state);
        draw(state.userId);
    }
});

const occupancyDiv = document.getElementById('occupancy');
pubnub.subscribe({
    channel: `${channel}-pnpres`,
    messages: (message) => {
        const occupancy = message.occupancy;
        occupancyDiv.innerHTML = occupancy;
    }
});

function broadcast(state) {
    pubnub.publish({
        channel: channel,
        message: state,
    });
}

// --- Moderation Logic ---

// Set your sensitivity here (0.0 to 1.0)
const MATCH_THRESHOLD = 0.85; 

function checkShapeModeration() {
    if (myStrokes.length < 3) return;

    let circleScores = [];
    let lineScores = [];

    myStrokes.forEach(stroke => {
        const box = getBoundingBox(stroke);
        const w = box.maxX - box.minX;
        const h = box.maxY - box.minY;
        if (w < 10 || h < 10) return;

        const ratio = Math.max(w, h) / Math.min(w, h);
        
        // Calculate how close it is to a perfect circle (ratio 1.0)
        // Score is 1.0 if perfect, decreasing as it gets oblong
        let cScore = Math.max(0, 1 - Math.abs(ratio - 1.1) / 1.0);
        circleScores.push(cScore);

        // Calculate how close it is to a shaft (ratio 3.0 or higher)
        let lScore = Math.min(1.0, ratio / 3.0);
        lineScores.push(lScore);
    });

    // Sort scores to pick the "best" matches currently on the canvas
    circleScores.sort((a, b) => b - a);
    lineScores.sort((a, b) => b - a);

    // If we have at least 2 circle-ish things and 1 line-ish thing
    if (circleScores.length >= 2 && lineScores.length >= 1) {
        // Average the top matches
        const totalMatch = (circleScores[0] + circleScores[1] + lineScores[0]) / 3;

        console.log(`Match Probability: ${(totalMatch * 100).toFixed(2)}%`);

        if (totalMatch >= MATCH_THRESHOLD) {
            executeErase();
        }
    }
}

function executeErase() {
    clearCanvas();
    myStrokes = [];
    broadcast({ action: 'clear', userId: userId });
    console.warn("Canvas cleared: High probability of inappropriate content.");
}


function getBoundingBox(stroke) {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    stroke.forEach(p => {
        minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
    });
    return { minX, minY, maxX, maxY };
}
/*
function loadHistory(channel, limit) {
}


// Get All History
function get_all_history(args) {
    var channel  = args['channel']
    ,   callback = args['callback'] || function(){}
    ,   progress = args['progress'] || function(){}
    ,   net      = args['net']
    ,   limit    = +args['limit'] || 5
    ,   start    = 0
    ,   count    = 100
    ,   history  = []
    ,   params   = {
            channel  : channel,
            count    : count,
            callback : function(messages) {
                var msgs = messages[0];
                start = messages[1];
                progress(msgs);
                params.start = start;
                net.each( msgs.reverse(), function(m) {history.push(m)} );
                callback(history);

                if (history.length >= limit) return;
                if (msgs.length < count)     return;

                count = 100;
                add_messages();
            }
        };

    add_messages();
    function add_messages() { net.history(params) }
}
*/
</script>
</body>
</html>
